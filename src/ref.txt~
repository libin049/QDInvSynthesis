 /// Visit - Walk the subtree of a statement and add extra
01380 ///   blocks for ternary operators, &&, and ||.  We also process "," and
01381 ///   DeclStmts (which may contain nested control-flow).
01382 CFGBlock *CFGBuilder::Visit(Stmt * S, AddStmtChoice asc) {
01383   if (!S) {
01384     badCFG = true;
01385     return nullptr;
01386   }
01387 
01388   if (Expr *E = dyn_cast<Expr>(S))
01389     S = E->IgnoreParens();
01390 
01391   switch (S->getStmtClass()) {
01392     default:
01393       return VisitStmt(S, asc);
01394 
01395     case Stmt::AddrLabelExprClass:
01396       return VisitAddrLabelExpr(cast<AddrLabelExpr>(S), asc);
01397 
01398     case Stmt::BinaryConditionalOperatorClass:
01399       return VisitConditionalOperator(cast<BinaryConditionalOperator>(S), asc);
01400 
01401     case Stmt::BinaryOperatorClass:
01402       return VisitBinaryOperator(cast<BinaryOperator>(S), asc);
01403 
01404     case Stmt::BlockExprClass:
01405       return VisitNoRecurse(cast<Expr>(S), asc);
01406 
01407     case Stmt::BreakStmtClass:
01408       return VisitBreakStmt(cast<BreakStmt>(S));
01409 
01410     case Stmt::CallExprClass:
01411     case Stmt::CXXOperatorCallExprClass:
01412     case Stmt::CXXMemberCallExprClass:
01413     case Stmt::UserDefinedLiteralClass:
01414       return VisitCallExpr(cast<CallExpr>(S), asc);
01415 
01416     case Stmt::CaseStmtClass:
01417       return VisitCaseStmt(cast<CaseStmt>(S));
01418 
01419     case Stmt::ChooseExprClass:
01420       return VisitChooseExpr(cast<ChooseExpr>(S), asc);
01421 
01422     case Stmt::CompoundStmtClass:
01423       return VisitCompoundStmt(cast<CompoundStmt>(S));
01424 
01425     case Stmt::ConditionalOperatorClass:
01426       return VisitConditionalOperator(cast<ConditionalOperator>(S), asc);
01427 
01428     case Stmt::ContinueStmtClass:
01429       return VisitContinueStmt(cast<ContinueStmt>(S));
01430 
01431     case Stmt::CXXCatchStmtClass:
01432       return VisitCXXCatchStmt(cast<CXXCatchStmt>(S));
01433 
01434     case Stmt::ExprWithCleanupsClass:
01435       return VisitExprWithCleanups(cast<ExprWithCleanups>(S), asc);
01436 
01437     case Stmt::CXXDefaultArgExprClass:
01438     case Stmt::CXXDefaultInitExprClass:
01439       // FIXME: The expression inside a CXXDefaultArgExpr is owned by the
01440       // called function's declaration, not by the caller. If we simply add
01441       // this expression to the CFG, we could end up with the same Expr
01442       // appearing multiple times.
01443       // PR13385 / <rdar://problem/12156507>
01444       //
01445       // It's likewise possible for multiple CXXDefaultInitExprs for the same
01446       // expression to be used in the same function (through aggregate
01447       // initialization).
01448       return VisitStmt(S, asc);
01449 
01450     case Stmt::CXXBindTemporaryExprClass:
01451       return VisitCXXBindTemporaryExpr(cast<CXXBindTemporaryExpr>(S), asc);
01452 
01453     case Stmt::CXXConstructExprClass:
01454       return VisitCXXConstructExpr(cast<CXXConstructExpr>(S), asc);
01455 
01456     case Stmt::CXXNewExprClass:
01457       return VisitCXXNewExpr(cast<CXXNewExpr>(S), asc);
01458 
01459     case Stmt::CXXDeleteExprClass:
01460       return VisitCXXDeleteExpr(cast<CXXDeleteExpr>(S), asc);
01461 
01462     case Stmt::CXXFunctionalCastExprClass:
01463       return VisitCXXFunctionalCastExpr(cast<CXXFunctionalCastExpr>(S), asc);
01464 
01465     case Stmt::CXXTemporaryObjectExprClass:
01466       return VisitCXXTemporaryObjectExpr(cast<CXXTemporaryObjectExpr>(S), asc);
01467 
01468     case Stmt::CXXThrowExprClass:
01469       return VisitCXXThrowExpr(cast<CXXThrowExpr>(S));
01470 
01471     case Stmt::CXXTryStmtClass:
01472       return VisitCXXTryStmt(cast<CXXTryStmt>(S));
01473 
01474     case Stmt::CXXForRangeStmtClass:
01475       return VisitCXXForRangeStmt(cast<CXXForRangeStmt>(S));
01476 
01477     case Stmt::DeclStmtClass:
01478       return VisitDeclStmt(cast<DeclStmt>(S));
01479 
01480     case Stmt::DefaultStmtClass:
01481       return VisitDefaultStmt(cast<DefaultStmt>(S));
01482 
01483     case Stmt::DoStmtClass:
01484       return VisitDoStmt(cast<DoStmt>(S));
01485 
01486     case Stmt::ForStmtClass:
01487       return VisitForStmt(cast<ForStmt>(S));
01488 
01489     case Stmt::GotoStmtClass:
01490       return VisitGotoStmt(cast<GotoStmt>(S));
01491 
01492     case Stmt::IfStmtClass:
01493       return VisitIfStmt(cast<IfStmt>(S));
01494 
01495     case Stmt::ImplicitCastExprClass:
01496       return VisitImplicitCastExpr(cast<ImplicitCastExpr>(S), asc);
01497 
01498     case Stmt::IndirectGotoStmtClass:
01499       return VisitIndirectGotoStmt(cast<IndirectGotoStmt>(S));
01500 
01501     case Stmt::LabelStmtClass:
01502       return VisitLabelStmt(cast<LabelStmt>(S));
01503 
01504     case Stmt::LambdaExprClass:
01505       return VisitLambdaExpr(cast<LambdaExpr>(S), asc);
01506 
01507     case Stmt::MemberExprClass:
01508       return VisitMemberExpr(cast<MemberExpr>(S), asc);
01509 
01510     case Stmt::NullStmtClass:
01511       return Block;
01512 
01513     case Stmt::ObjCAtCatchStmtClass:
01514       return VisitObjCAtCatchStmt(cast<ObjCAtCatchStmt>(S));
01515 
01516     case Stmt::ObjCAutoreleasePoolStmtClass:
01517     return VisitObjCAutoreleasePoolStmt(cast<ObjCAutoreleasePoolStmt>(S));
01518 
01519     case Stmt::ObjCAtSynchronizedStmtClass:
01520       return VisitObjCAtSynchronizedStmt(cast<ObjCAtSynchronizedStmt>(S));
01521 
01522     case Stmt::ObjCAtThrowStmtClass:
01523       return VisitObjCAtThrowStmt(cast<ObjCAtThrowStmt>(S));
01524 
01525     case Stmt::ObjCAtTryStmtClass:
01526       return VisitObjCAtTryStmt(cast<ObjCAtTryStmt>(S));
01527 
01528     case Stmt::ObjCForCollectionStmtClass:
01529       return VisitObjCForCollectionStmt(cast<ObjCForCollectionStmt>(S));
01530 
01531     case Stmt::OpaqueValueExprClass:
01532       return Block;
01533 
01534     case Stmt::PseudoObjectExprClass:
01535       return VisitPseudoObjectExpr(cast<PseudoObjectExpr>(S));
01536 
01537     case Stmt::ReturnStmtClass:
01538       return VisitReturnStmt(cast<ReturnStmt>(S));
01539 
01540     case Stmt::UnaryExprOrTypeTraitExprClass:
01541       return VisitUnaryExprOrTypeTraitExpr(cast<UnaryExprOrTypeTraitExpr>(S),
01542                                            asc);
01543 
01544     case Stmt::StmtExprClass:
01545       return VisitStmtExpr(cast<StmtExpr>(S), asc);
01546 
01547     case Stmt::SwitchStmtClass:
01548       return VisitSwitchStmt(cast<SwitchStmt>(S));
01549 
01550     case Stmt::UnaryOperatorClass:
01551       return VisitUnaryOperator(cast<UnaryOperator>(S), asc);
01552 
01553     case Stmt::WhileStmtClass:
01554       return VisitWhileStmt(cast<WhileStmt>(S));
01555   }
01556 }
